// Code generated by goagen v1.3.1, DO NOT EDIT.
//
// API "cryptopages": user Resource Client
//
// Command:
// $ goagen
// --design=github.com/tutley/cryptopages/design
// --out=$(GOPATH)/src/github.com/tutley/cryptopages
// --regen=true
// --version=v1.3.1

package client

import (
	"bytes"
	"context"
	"fmt"
	"net/http"
	"net/url"
)

// CreateUserPayload is the user create action payload.
type CreateUserPayload struct {
	// Is this user available to provide work
	Available *bool `form:"available,omitempty" json:"available,omitempty" xml:"available,omitempty"`
	// The coins this user will accept as payment
	Coins *struct {
		// Accepts Bitcoin Cash
		Bcc *bool `form:"bcc,omitempty" json:"bcc,omitempty" xml:"bcc,omitempty"`
		// Accepts Bitcoin
		Btc *bool `form:"btc,omitempty" json:"btc,omitempty" xml:"btc,omitempty"`
		// Accepts Ethereum
		Eth *bool `form:"eth,omitempty" json:"eth,omitempty" xml:"eth,omitempty"`
		// Accepts Litecoin
		Ltc *bool `form:"ltc,omitempty" json:"ltc,omitempty" xml:"ltc,omitempty"`
		// Accepts Neo
		Neo *bool `form:"neo,omitempty" json:"neo,omitempty" xml:"neo,omitempty"`
		// Accepts some other coin
		Other *struct {
			// Name of the other coin accepted
			Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
		} `form:"other,omitempty" json:"other,omitempty" xml:"other,omitempty"`
		// Accepts Lumen
		Xlm *bool `form:"xlm,omitempty" json:"xlm,omitempty" xml:"xlm,omitempty"`
		// Accepts Ripple
		Xrp *bool `form:"xrp,omitempty" json:"xrp,omitempty" xml:"xrp,omitempty"`
	} `form:"coins,omitempty" json:"coins,omitempty" xml:"coins,omitempty"`
	// The user's email address
	Email *struct {
		// Should the email address be shown to others
		MakePublic *bool `form:"makePublic,omitempty" json:"makePublic,omitempty" xml:"makePublic,omitempty"`
		// the email address
		Value *string `form:"value,omitempty" json:"value,omitempty" xml:"value,omitempty"`
	} `form:"email,omitempty" json:"email,omitempty" xml:"email,omitempty"`
	JobCategory    *string `form:"jobCategory,omitempty" json:"jobCategory,omitempty" xml:"jobCategory,omitempty"`
	JobDescription *string `form:"jobDescription,omitempty" json:"jobDescription,omitempty" xml:"jobDescription,omitempty"`
	// the user's location geographically
	Location *struct {
		// Should the location be shown to others
		MakePublic *bool `form:"makePublic,omitempty" json:"makePublic,omitempty" xml:"makePublic,omitempty"`
		// the location
		Value *string `form:"value,omitempty" json:"value,omitempty" xml:"value,omitempty"`
	} `form:"location,omitempty" json:"location,omitempty" xml:"location,omitempty"`
	// The user's full name
	Name string `form:"name" json:"name" xml:"name"`
	// A password (only exposed to user)
	Password string   `form:"password" json:"password" xml:"password"`
	Skills   []string `form:"skills,omitempty" json:"skills,omitempty" xml:"skills,omitempty"`
	// The unique username for this person
	Username string `form:"username" json:"username" xml:"username"`
}

// CreateUserPath computes a request path to the create action of user.
func CreateUserPath() string {

	return fmt.Sprintf("/user")
}

// Register new user
func (c *Client) CreateUser(ctx context.Context, path string, payload *CreateUserPayload) (*http.Response, error) {
	req, err := c.NewCreateUserRequest(ctx, path, payload)
	if err != nil {
		return nil, err
	}
	return c.Client.Do(ctx, req)
}

// NewCreateUserRequest create the request corresponding to the create action endpoint of the user resource.
func (c *Client) NewCreateUserRequest(ctx context.Context, path string, payload *CreateUserPayload) (*http.Request, error) {
	var body bytes.Buffer
	err := c.Encoder.Encode(payload, &body, "*/*")
	if err != nil {
		return nil, fmt.Errorf("failed to encode body: %s", err)
	}
	scheme := c.Scheme
	if scheme == "" {
		scheme = "http"
	}
	u := url.URL{Host: c.Host, Scheme: scheme, Path: path}
	req, err := http.NewRequest("POST", u.String(), &body)
	if err != nil {
		return nil, err
	}
	header := req.Header
	header.Set("Content-Type", "application/json")
	return req, nil
}

// DeleteUserPath computes a request path to the delete action of user.
func DeleteUserPath(username string) string {
	param0 := username

	return fmt.Sprintf("/user/%s", param0)
}

// DeleteUser makes a request to the delete action endpoint of the user resource
func (c *Client) DeleteUser(ctx context.Context, path string) (*http.Response, error) {
	req, err := c.NewDeleteUserRequest(ctx, path)
	if err != nil {
		return nil, err
	}
	return c.Client.Do(ctx, req)
}

// NewDeleteUserRequest create the request corresponding to the delete action endpoint of the user resource.
func (c *Client) NewDeleteUserRequest(ctx context.Context, path string) (*http.Request, error) {
	scheme := c.Scheme
	if scheme == "" {
		scheme = "http"
	}
	u := url.URL{Host: c.Host, Scheme: scheme, Path: path}
	req, err := http.NewRequest("DELETE", u.String(), nil)
	if err != nil {
		return nil, err
	}
	if c.JWTSigner != nil {
		if err := c.JWTSigner.Sign(req); err != nil {
			return nil, err
		}
	}
	return req, nil
}

// SearchUserPath computes a request path to the search action of user.
func SearchUserPath() string {

	return fmt.Sprintf("/user")
}

// Search users based on different criteria
func (c *Client) SearchUser(ctx context.Context, path string, coins *string, jobCategory *string, skills *string) (*http.Response, error) {
	req, err := c.NewSearchUserRequest(ctx, path, coins, jobCategory, skills)
	if err != nil {
		return nil, err
	}
	return c.Client.Do(ctx, req)
}

// NewSearchUserRequest create the request corresponding to the search action endpoint of the user resource.
func (c *Client) NewSearchUserRequest(ctx context.Context, path string, coins *string, jobCategory *string, skills *string) (*http.Request, error) {
	scheme := c.Scheme
	if scheme == "" {
		scheme = "http"
	}
	u := url.URL{Host: c.Host, Scheme: scheme, Path: path}
	values := u.Query()
	if coins != nil {
		values.Set("coins", *coins)
	}
	if jobCategory != nil {
		values.Set("jobCategory", *jobCategory)
	}
	if skills != nil {
		values.Set("skills", *skills)
	}
	u.RawQuery = values.Encode()
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, err
	}
	if c.JWTSigner != nil {
		if err := c.JWTSigner.Sign(req); err != nil {
			return nil, err
		}
	}
	return req, nil
}

// ShowUserPath computes a request path to the show action of user.
func ShowUserPath(username string) string {
	param0 := username

	return fmt.Sprintf("/user/%s", param0)
}

// Get user by username
func (c *Client) ShowUser(ctx context.Context, path string) (*http.Response, error) {
	req, err := c.NewShowUserRequest(ctx, path)
	if err != nil {
		return nil, err
	}
	return c.Client.Do(ctx, req)
}

// NewShowUserRequest create the request corresponding to the show action endpoint of the user resource.
func (c *Client) NewShowUserRequest(ctx context.Context, path string) (*http.Request, error) {
	scheme := c.Scheme
	if scheme == "" {
		scheme = "http"
	}
	u := url.URL{Host: c.Host, Scheme: scheme, Path: path}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, err
	}
	if c.JWTSigner != nil {
		if err := c.JWTSigner.Sign(req); err != nil {
			return nil, err
		}
	}
	return req, nil
}

// UpdateUserPath computes a request path to the update action of user.
func UpdateUserPath(username string) string {
	param0 := username

	return fmt.Sprintf("/user/%s", param0)
}

// UpdateUser makes a request to the update action endpoint of the user resource
func (c *Client) UpdateUser(ctx context.Context, path string, payload *UserPayload) (*http.Response, error) {
	req, err := c.NewUpdateUserRequest(ctx, path, payload)
	if err != nil {
		return nil, err
	}
	return c.Client.Do(ctx, req)
}

// NewUpdateUserRequest create the request corresponding to the update action endpoint of the user resource.
func (c *Client) NewUpdateUserRequest(ctx context.Context, path string, payload *UserPayload) (*http.Request, error) {
	var body bytes.Buffer
	err := c.Encoder.Encode(payload, &body, "*/*")
	if err != nil {
		return nil, fmt.Errorf("failed to encode body: %s", err)
	}
	scheme := c.Scheme
	if scheme == "" {
		scheme = "http"
	}
	u := url.URL{Host: c.Host, Scheme: scheme, Path: path}
	req, err := http.NewRequest("PATCH", u.String(), &body)
	if err != nil {
		return nil, err
	}
	header := req.Header
	header.Set("Content-Type", "application/json")
	if c.JWTSigner != nil {
		if err := c.JWTSigner.Sign(req); err != nil {
			return nil, err
		}
	}
	return req, nil
}
