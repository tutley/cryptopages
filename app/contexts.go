// Code generated by goagen v1.3.1, DO NOT EDIT.
//
// API "cryptopages": Application Contexts
//
// Command:
// $ goagen
// --design=github.com/tutley/cryptopages/design
// --out=$(GOPATH)/src/github.com/tutley/cryptopages
// --regen=true
// --version=v1.3.1

package app

import (
	"context"
	"github.com/goadesign/goa"
	"net/http"
	"unicode/utf8"
)

// HealthHealthContext provides the health health action context.
type HealthHealthContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
}

// NewHealthHealthContext parses the incoming request URL and body, performs validations and creates the
// context used by the health controller health action.
func NewHealthHealthContext(ctx context.Context, r *http.Request, service *goa.Service) (*HealthHealthContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := HealthHealthContext{Context: ctx, ResponseData: resp, RequestData: req}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *HealthHealthContext) OK(resp []byte) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "text/plain")
	}
	ctx.ResponseData.WriteHeader(200)
	_, err := ctx.ResponseData.Write(resp)
	return err
}

// SigninJWTContext provides the jwt signin action context.
type SigninJWTContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
}

// NewSigninJWTContext parses the incoming request URL and body, performs validations and creates the
// context used by the jwt controller signin action.
func NewSigninJWTContext(ctx context.Context, r *http.Request, service *goa.Service) (*SigninJWTContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := SigninJWTContext{Context: ctx, ResponseData: resp, RequestData: req}
	return &rctx, err
}

// NoContent sends a HTTP response with status code 204.
func (ctx *SigninJWTContext) NoContent() error {
	ctx.ResponseData.WriteHeader(204)
	return nil
}

// Unauthorized sends a HTTP response with status code 401.
func (ctx *SigninJWTContext) Unauthorized() error {
	ctx.ResponseData.WriteHeader(401)
	return nil
}

// CheckUsernameUserContext provides the user checkUsername action context.
type CheckUsernameUserContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	Username string
}

// NewCheckUsernameUserContext parses the incoming request URL and body, performs validations and creates the
// context used by the user controller checkUsername action.
func NewCheckUsernameUserContext(ctx context.Context, r *http.Request, service *goa.Service) (*CheckUsernameUserContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := CheckUsernameUserContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramUsername := req.Params["username"]
	if len(paramUsername) > 0 {
		rawUsername := paramUsername[0]
		rctx.Username = rawUsername
		if utf8.RuneCountInString(rctx.Username) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`username`, rctx.Username, utf8.RuneCountInString(rctx.Username), 1, true))
		}
	}
	return &rctx, err
}

// NoContent sends a HTTP response with status code 204.
func (ctx *CheckUsernameUserContext) NoContent() error {
	ctx.ResponseData.WriteHeader(204)
	return nil
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *CheckUsernameUserContext) BadRequest(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 400, r)
}

// NotFound sends a HTTP response with status code 404.
func (ctx *CheckUsernameUserContext) NotFound() error {
	ctx.ResponseData.WriteHeader(404)
	return nil
}

// CreateUserContext provides the user create action context.
type CreateUserContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	Payload *CreateUserPayload
}

// NewCreateUserContext parses the incoming request URL and body, performs validations and creates the
// context used by the user controller create action.
func NewCreateUserContext(ctx context.Context, r *http.Request, service *goa.Service) (*CreateUserContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := CreateUserContext{Context: ctx, ResponseData: resp, RequestData: req}
	return &rctx, err
}

// createUserPayload is the user create action payload.
type createUserPayload struct {
	// Is this user available to provide work
	Available *bool `form:"available,omitempty" json:"available,omitempty" xml:"available,omitempty"`
	// The coins this user will accept as payment
	Coins *struct {
		// Accepts Bitcoin Cash
		Bcc *bool `form:"bcc,omitempty" json:"bcc,omitempty" xml:"bcc,omitempty"`
		// Accepts Bitcoin
		Btc *bool `form:"btc,omitempty" json:"btc,omitempty" xml:"btc,omitempty"`
		// Accepts Ethereum
		Eth *bool `form:"eth,omitempty" json:"eth,omitempty" xml:"eth,omitempty"`
		// Accepts Litecoin
		Ltc *bool `form:"ltc,omitempty" json:"ltc,omitempty" xml:"ltc,omitempty"`
		// Accepts Neo
		Neo *bool `form:"neo,omitempty" json:"neo,omitempty" xml:"neo,omitempty"`
		// Accepts Some Other Coin
		Other *bool `form:"other,omitempty" json:"other,omitempty" xml:"other,omitempty"`
		// Accepts Lumen
		Xlm *bool `form:"xlm,omitempty" json:"xlm,omitempty" xml:"xlm,omitempty"`
		// Accepts Ripple
		Xrp *bool `form:"xrp,omitempty" json:"xrp,omitempty" xml:"xrp,omitempty"`
	} `form:"coins,omitempty" json:"coins,omitempty" xml:"coins,omitempty"`
	// The user's email address
	Email *struct {
		// Should the email address be shown to others
		MakePublic *bool `form:"makePublic,omitempty" json:"makePublic,omitempty" xml:"makePublic,omitempty"`
		// the email address
		Value *string `form:"value,omitempty" json:"value,omitempty" xml:"value,omitempty"`
	} `form:"email,omitempty" json:"email,omitempty" xml:"email,omitempty"`
	JobCategory    *string `form:"jobCategory,omitempty" json:"jobCategory,omitempty" xml:"jobCategory,omitempty"`
	JobDescription *string `form:"jobDescription,omitempty" json:"jobDescription,omitempty" xml:"jobDescription,omitempty"`
	// the user's location geographically
	Location *struct {
		// Should the location be shown to others
		MakePublic *bool `form:"makePublic,omitempty" json:"makePublic,omitempty" xml:"makePublic,omitempty"`
		// the location
		Value *string `form:"value,omitempty" json:"value,omitempty" xml:"value,omitempty"`
	} `form:"location,omitempty" json:"location,omitempty" xml:"location,omitempty"`
	// The user's full name
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// Name of the other coin a user accepts
	OtherCoin *string `form:"otherCoin,omitempty" json:"otherCoin,omitempty" xml:"otherCoin,omitempty"`
	// A password (only exposed to user)
	Password *string  `form:"password,omitempty" json:"password,omitempty" xml:"password,omitempty"`
	Skills   []string `form:"skills,omitempty" json:"skills,omitempty" xml:"skills,omitempty"`
	// The unique username for this person
	Username *string `form:"username,omitempty" json:"username,omitempty" xml:"username,omitempty"`
}

// Validate runs the validation rules defined in the design.
func (payload *createUserPayload) Validate() (err error) {
	if payload.Name == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`raw`, "name"))
	}
	if payload.Username == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`raw`, "username"))
	}
	if payload.Password == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`raw`, "password"))
	}
	if payload.Email != nil {
		if payload.Email.Value != nil {
			if err2 := goa.ValidateFormat(goa.FormatEmail, *payload.Email.Value); err2 != nil {
				err = goa.MergeErrors(err, goa.InvalidFormatError(`raw.email.value`, *payload.Email.Value, goa.FormatEmail, err2))
			}
		}
		if payload.Email.Value != nil {
			if utf8.RuneCountInString(*payload.Email.Value) < 5 {
				err = goa.MergeErrors(err, goa.InvalidLengthError(`raw.email.value`, *payload.Email.Value, utf8.RuneCountInString(*payload.Email.Value), 5, true))
			}
		}
	}
	if payload.JobCategory != nil {
		if !(*payload.JobCategory == "hardware" || *payload.JobCategory == "software" || *payload.JobCategory == "writing" || *payload.JobCategory == "legal" || *payload.JobCategory == "labor" || *payload.JobCategory == "automotive" || *payload.JobCategory == "services" || *payload.JobCategory == "others") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`raw.jobCategory`, *payload.JobCategory, []interface{}{"hardware", "software", "writing", "legal", "labor", "automotive", "services", "others"}))
		}
	}
	if payload.Location != nil {
		if payload.Location.Value != nil {
			if utf8.RuneCountInString(*payload.Location.Value) < 2 {
				err = goa.MergeErrors(err, goa.InvalidLengthError(`raw.location.value`, *payload.Location.Value, utf8.RuneCountInString(*payload.Location.Value), 2, true))
			}
		}
	}
	if payload.Name != nil {
		if utf8.RuneCountInString(*payload.Name) < 2 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`raw.name`, *payload.Name, utf8.RuneCountInString(*payload.Name), 2, true))
		}
	}
	if payload.Password != nil {
		if utf8.RuneCountInString(*payload.Password) < 8 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`raw.password`, *payload.Password, utf8.RuneCountInString(*payload.Password), 8, true))
		}
	}
	if payload.Username != nil {
		if utf8.RuneCountInString(*payload.Username) < 2 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`raw.username`, *payload.Username, utf8.RuneCountInString(*payload.Username), 2, true))
		}
	}
	return
}

// Publicize creates CreateUserPayload from createUserPayload
func (payload *createUserPayload) Publicize() *CreateUserPayload {
	var pub CreateUserPayload
	if payload.Available != nil {
		pub.Available = payload.Available
	}
	if payload.Coins != nil {
		pub.Coins = &struct {
			// Accepts Bitcoin Cash
			Bcc *bool `form:"bcc,omitempty" json:"bcc,omitempty" xml:"bcc,omitempty"`
			// Accepts Bitcoin
			Btc *bool `form:"btc,omitempty" json:"btc,omitempty" xml:"btc,omitempty"`
			// Accepts Ethereum
			Eth *bool `form:"eth,omitempty" json:"eth,omitempty" xml:"eth,omitempty"`
			// Accepts Litecoin
			Ltc *bool `form:"ltc,omitempty" json:"ltc,omitempty" xml:"ltc,omitempty"`
			// Accepts Neo
			Neo *bool `form:"neo,omitempty" json:"neo,omitempty" xml:"neo,omitempty"`
			// Accepts Some Other Coin
			Other *bool `form:"other,omitempty" json:"other,omitempty" xml:"other,omitempty"`
			// Accepts Lumen
			Xlm *bool `form:"xlm,omitempty" json:"xlm,omitempty" xml:"xlm,omitempty"`
			// Accepts Ripple
			Xrp *bool `form:"xrp,omitempty" json:"xrp,omitempty" xml:"xrp,omitempty"`
		}{}
		if payload.Coins.Bcc != nil {
			pub.Coins.Bcc = payload.Coins.Bcc
		}
		if payload.Coins.Btc != nil {
			pub.Coins.Btc = payload.Coins.Btc
		}
		if payload.Coins.Eth != nil {
			pub.Coins.Eth = payload.Coins.Eth
		}
		if payload.Coins.Ltc != nil {
			pub.Coins.Ltc = payload.Coins.Ltc
		}
		if payload.Coins.Neo != nil {
			pub.Coins.Neo = payload.Coins.Neo
		}
		if payload.Coins.Other != nil {
			pub.Coins.Other = payload.Coins.Other
		}
		if payload.Coins.Xlm != nil {
			pub.Coins.Xlm = payload.Coins.Xlm
		}
		if payload.Coins.Xrp != nil {
			pub.Coins.Xrp = payload.Coins.Xrp
		}
	}
	if payload.Email != nil {
		pub.Email = &struct {
			// Should the email address be shown to others
			MakePublic *bool `form:"makePublic,omitempty" json:"makePublic,omitempty" xml:"makePublic,omitempty"`
			// the email address
			Value *string `form:"value,omitempty" json:"value,omitempty" xml:"value,omitempty"`
		}{}
		if payload.Email.MakePublic != nil {
			pub.Email.MakePublic = payload.Email.MakePublic
		}
		if payload.Email.Value != nil {
			pub.Email.Value = payload.Email.Value
		}
	}
	if payload.JobCategory != nil {
		pub.JobCategory = payload.JobCategory
	}
	if payload.JobDescription != nil {
		pub.JobDescription = payload.JobDescription
	}
	if payload.Location != nil {
		pub.Location = &struct {
			// Should the location be shown to others
			MakePublic *bool `form:"makePublic,omitempty" json:"makePublic,omitempty" xml:"makePublic,omitempty"`
			// the location
			Value *string `form:"value,omitempty" json:"value,omitempty" xml:"value,omitempty"`
		}{}
		if payload.Location.MakePublic != nil {
			pub.Location.MakePublic = payload.Location.MakePublic
		}
		if payload.Location.Value != nil {
			pub.Location.Value = payload.Location.Value
		}
	}
	if payload.Name != nil {
		pub.Name = *payload.Name
	}
	if payload.OtherCoin != nil {
		pub.OtherCoin = payload.OtherCoin
	}
	if payload.Password != nil {
		pub.Password = *payload.Password
	}
	if payload.Skills != nil {
		pub.Skills = payload.Skills
	}
	if payload.Username != nil {
		pub.Username = *payload.Username
	}
	return &pub
}

// CreateUserPayload is the user create action payload.
type CreateUserPayload struct {
	// Is this user available to provide work
	Available *bool `form:"available,omitempty" json:"available,omitempty" xml:"available,omitempty"`
	// The coins this user will accept as payment
	Coins *struct {
		// Accepts Bitcoin Cash
		Bcc *bool `form:"bcc,omitempty" json:"bcc,omitempty" xml:"bcc,omitempty"`
		// Accepts Bitcoin
		Btc *bool `form:"btc,omitempty" json:"btc,omitempty" xml:"btc,omitempty"`
		// Accepts Ethereum
		Eth *bool `form:"eth,omitempty" json:"eth,omitempty" xml:"eth,omitempty"`
		// Accepts Litecoin
		Ltc *bool `form:"ltc,omitempty" json:"ltc,omitempty" xml:"ltc,omitempty"`
		// Accepts Neo
		Neo *bool `form:"neo,omitempty" json:"neo,omitempty" xml:"neo,omitempty"`
		// Accepts Some Other Coin
		Other *bool `form:"other,omitempty" json:"other,omitempty" xml:"other,omitempty"`
		// Accepts Lumen
		Xlm *bool `form:"xlm,omitempty" json:"xlm,omitempty" xml:"xlm,omitempty"`
		// Accepts Ripple
		Xrp *bool `form:"xrp,omitempty" json:"xrp,omitempty" xml:"xrp,omitempty"`
	} `form:"coins,omitempty" json:"coins,omitempty" xml:"coins,omitempty"`
	// The user's email address
	Email *struct {
		// Should the email address be shown to others
		MakePublic *bool `form:"makePublic,omitempty" json:"makePublic,omitempty" xml:"makePublic,omitempty"`
		// the email address
		Value *string `form:"value,omitempty" json:"value,omitempty" xml:"value,omitempty"`
	} `form:"email,omitempty" json:"email,omitempty" xml:"email,omitempty"`
	JobCategory    *string `form:"jobCategory,omitempty" json:"jobCategory,omitempty" xml:"jobCategory,omitempty"`
	JobDescription *string `form:"jobDescription,omitempty" json:"jobDescription,omitempty" xml:"jobDescription,omitempty"`
	// the user's location geographically
	Location *struct {
		// Should the location be shown to others
		MakePublic *bool `form:"makePublic,omitempty" json:"makePublic,omitempty" xml:"makePublic,omitempty"`
		// the location
		Value *string `form:"value,omitempty" json:"value,omitempty" xml:"value,omitempty"`
	} `form:"location,omitempty" json:"location,omitempty" xml:"location,omitempty"`
	// The user's full name
	Name string `form:"name" json:"name" xml:"name"`
	// Name of the other coin a user accepts
	OtherCoin *string `form:"otherCoin,omitempty" json:"otherCoin,omitempty" xml:"otherCoin,omitempty"`
	// A password (only exposed to user)
	Password string   `form:"password" json:"password" xml:"password"`
	Skills   []string `form:"skills,omitempty" json:"skills,omitempty" xml:"skills,omitempty"`
	// The unique username for this person
	Username string `form:"username" json:"username" xml:"username"`
}

// Validate runs the validation rules defined in the design.
func (payload *CreateUserPayload) Validate() (err error) {
	if payload.Name == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`raw`, "name"))
	}
	if payload.Username == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`raw`, "username"))
	}
	if payload.Password == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`raw`, "password"))
	}
	if payload.Email != nil {
		if payload.Email.Value != nil {
			if err2 := goa.ValidateFormat(goa.FormatEmail, *payload.Email.Value); err2 != nil {
				err = goa.MergeErrors(err, goa.InvalidFormatError(`raw.email.value`, *payload.Email.Value, goa.FormatEmail, err2))
			}
		}
		if payload.Email.Value != nil {
			if utf8.RuneCountInString(*payload.Email.Value) < 5 {
				err = goa.MergeErrors(err, goa.InvalidLengthError(`raw.email.value`, *payload.Email.Value, utf8.RuneCountInString(*payload.Email.Value), 5, true))
			}
		}
	}
	if payload.JobCategory != nil {
		if !(*payload.JobCategory == "hardware" || *payload.JobCategory == "software" || *payload.JobCategory == "writing" || *payload.JobCategory == "legal" || *payload.JobCategory == "labor" || *payload.JobCategory == "automotive" || *payload.JobCategory == "services" || *payload.JobCategory == "others") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`raw.jobCategory`, *payload.JobCategory, []interface{}{"hardware", "software", "writing", "legal", "labor", "automotive", "services", "others"}))
		}
	}
	if payload.Location != nil {
		if payload.Location.Value != nil {
			if utf8.RuneCountInString(*payload.Location.Value) < 2 {
				err = goa.MergeErrors(err, goa.InvalidLengthError(`raw.location.value`, *payload.Location.Value, utf8.RuneCountInString(*payload.Location.Value), 2, true))
			}
		}
	}
	if utf8.RuneCountInString(payload.Name) < 2 {
		err = goa.MergeErrors(err, goa.InvalidLengthError(`raw.name`, payload.Name, utf8.RuneCountInString(payload.Name), 2, true))
	}
	if utf8.RuneCountInString(payload.Password) < 8 {
		err = goa.MergeErrors(err, goa.InvalidLengthError(`raw.password`, payload.Password, utf8.RuneCountInString(payload.Password), 8, true))
	}
	if utf8.RuneCountInString(payload.Username) < 2 {
		err = goa.MergeErrors(err, goa.InvalidLengthError(`raw.username`, payload.Username, utf8.RuneCountInString(payload.Username), 2, true))
	}
	return
}

// Created sends a HTTP response with status code 201.
func (ctx *CreateUserContext) Created() error {
	ctx.ResponseData.WriteHeader(201)
	return nil
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *CreateUserContext) BadRequest(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 400, r)
}

// NotFound sends a HTTP response with status code 404.
func (ctx *CreateUserContext) NotFound() error {
	ctx.ResponseData.WriteHeader(404)
	return nil
}

// DeleteUserContext provides the user delete action context.
type DeleteUserContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	Username string
}

// NewDeleteUserContext parses the incoming request URL and body, performs validations and creates the
// context used by the user controller delete action.
func NewDeleteUserContext(ctx context.Context, r *http.Request, service *goa.Service) (*DeleteUserContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := DeleteUserContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramUsername := req.Params["username"]
	if len(paramUsername) > 0 {
		rawUsername := paramUsername[0]
		rctx.Username = rawUsername
		if utf8.RuneCountInString(rctx.Username) < 2 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`username`, rctx.Username, utf8.RuneCountInString(rctx.Username), 2, true))
		}
	}
	return &rctx, err
}

// NoContent sends a HTTP response with status code 204.
func (ctx *DeleteUserContext) NoContent() error {
	ctx.ResponseData.WriteHeader(204)
	return nil
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *DeleteUserContext) BadRequest(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 400, r)
}

// NotFound sends a HTTP response with status code 404.
func (ctx *DeleteUserContext) NotFound() error {
	ctx.ResponseData.WriteHeader(404)
	return nil
}

// SearchUserContext provides the user search action context.
type SearchUserContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	Coins       *string
	JobCategory *string
	Skills      *string
}

// NewSearchUserContext parses the incoming request URL and body, performs validations and creates the
// context used by the user controller search action.
func NewSearchUserContext(ctx context.Context, r *http.Request, service *goa.Service) (*SearchUserContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := SearchUserContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramCoins := req.Params["coins"]
	if len(paramCoins) > 0 {
		rawCoins := paramCoins[0]
		rctx.Coins = &rawCoins
	}
	paramJobCategory := req.Params["jobCategory"]
	if len(paramJobCategory) > 0 {
		rawJobCategory := paramJobCategory[0]
		rctx.JobCategory = &rawJobCategory
		if rctx.JobCategory != nil {
			if !(*rctx.JobCategory == "hardware" || *rctx.JobCategory == "software" || *rctx.JobCategory == "writing" || *rctx.JobCategory == "legal" || *rctx.JobCategory == "labor" || *rctx.JobCategory == "automotive" || *rctx.JobCategory == "services" || *rctx.JobCategory == "others") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError(`jobCategory`, *rctx.JobCategory, []interface{}{"hardware", "software", "writing", "legal", "labor", "automotive", "services", "others"}))
			}
		}
	}
	paramSkills := req.Params["skills"]
	if len(paramSkills) > 0 {
		rawSkills := paramSkills[0]
		rctx.Skills = &rawSkills
	}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *SearchUserContext) OK(r CryptopagesUserCollection) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.cryptopages.user; type=collection")
	}
	if r == nil {
		r = CryptopagesUserCollection{}
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// OKTiny sends a HTTP response with status code 200.
func (ctx *SearchUserContext) OKTiny(r CryptopagesUserTinyCollection) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.cryptopages.user; type=collection")
	}
	if r == nil {
		r = CryptopagesUserTinyCollection{}
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *SearchUserContext) BadRequest(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 400, r)
}

// NotFound sends a HTTP response with status code 404.
func (ctx *SearchUserContext) NotFound() error {
	ctx.ResponseData.WriteHeader(404)
	return nil
}

// ShowUserContext provides the user show action context.
type ShowUserContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	Username string
}

// NewShowUserContext parses the incoming request URL and body, performs validations and creates the
// context used by the user controller show action.
func NewShowUserContext(ctx context.Context, r *http.Request, service *goa.Service) (*ShowUserContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := ShowUserContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramUsername := req.Params["username"]
	if len(paramUsername) > 0 {
		rawUsername := paramUsername[0]
		rctx.Username = rawUsername
		if utf8.RuneCountInString(rctx.Username) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`username`, rctx.Username, utf8.RuneCountInString(rctx.Username), 1, true))
		}
	}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *ShowUserContext) OK(r *CryptopagesUser) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.cryptopages.user")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// OKTiny sends a HTTP response with status code 200.
func (ctx *ShowUserContext) OKTiny(r *CryptopagesUserTiny) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.cryptopages.user")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *ShowUserContext) BadRequest(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 400, r)
}

// NotFound sends a HTTP response with status code 404.
func (ctx *ShowUserContext) NotFound() error {
	ctx.ResponseData.WriteHeader(404)
	return nil
}

// UpdateUserContext provides the user update action context.
type UpdateUserContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	Username string
	Payload  *UserPayload
}

// NewUpdateUserContext parses the incoming request URL and body, performs validations and creates the
// context used by the user controller update action.
func NewUpdateUserContext(ctx context.Context, r *http.Request, service *goa.Service) (*UpdateUserContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := UpdateUserContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramUsername := req.Params["username"]
	if len(paramUsername) > 0 {
		rawUsername := paramUsername[0]
		rctx.Username = rawUsername
		if utf8.RuneCountInString(rctx.Username) < 2 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`username`, rctx.Username, utf8.RuneCountInString(rctx.Username), 2, true))
		}
	}
	return &rctx, err
}

// NoContent sends a HTTP response with status code 204.
func (ctx *UpdateUserContext) NoContent() error {
	ctx.ResponseData.WriteHeader(204)
	return nil
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *UpdateUserContext) BadRequest(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 400, r)
}

// NotFound sends a HTTP response with status code 404.
func (ctx *UpdateUserContext) NotFound() error {
	ctx.ResponseData.WriteHeader(404)
	return nil
}
